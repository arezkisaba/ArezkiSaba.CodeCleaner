using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Formatting;
using System.Reflection;

namespace ArezkiSaba.CodeCleaner.Extensions;

public static class WorkspaceExtensions
{
    public static async Task<Workspace> CleanAndRefactorAsync(
        this Workspace workspace)
    {
        await workspace.CleanAsync();
        await workspace.RefactorAsync();
        return workspace;
    }

    #region Private use

    private static async Task CleanAsync(
        this Workspace workspace)
    {
        var changesCount = 0;
        var newSolution = workspace.CurrentSolution;
        var projectIds = workspace.CurrentSolution.ProjectIds;

        foreach (var projectId in projectIds)
        {
            var project = newSolution.GetProject(projectId);
            var documentIds = project.DocumentIds;
            foreach (var documentId in documentIds)
            {
                var originalDocument = project.GetDocument(documentId);
                var originalRoot = await originalDocument.GetSyntaxRootAsync();
                if (originalDocument.IsAutoGenerated() || originalRoot.BeginsWithAutoGeneratedComment())
                {
                    continue;
                }

                var updatedDocument = await originalDocument.StartTypeInferenceRewriterAsync();
                updatedDocument = await updatedDocument.StartReadonlyModifierFieldRewriterAsync();
                updatedDocument = await updatedDocument.StartUsingDirectiveSorterAsync();
                updatedDocument = await updatedDocument.StartDuplicatedUsingDirectiveRemoverAsync();
                updatedDocument = await updatedDocument.StartDuplicatedEmptyLinesRemoverAsync();
                updatedDocument = await updatedDocument.StartDuplicatedMethodEmptyLinesRemoverAsync();
                updatedDocument = await updatedDocument.ReorderClassMembersAsync();
                updatedDocument = await updatedDocument.StartMethodDeclarationParameterLineBreakerAsync();
                updatedDocument = await updatedDocument.StartInvocationExpressionArgumentLineBreakerAsync();
                updatedDocument = await Formatter.FormatAsync(updatedDocument);

                project = updatedDocument.Project;
                newSolution = project.Solution;

                var originalText = (await originalDocument.GetTextAsync()).ToString();
                var updatedText = (await updatedDocument.GetTextAsync()).ToString();
                if (!originalText.Equals(updatedText))
                {
                    changesCount++;
                }
            }
        }

        ApplyChanges(workspace, newSolution, changesCount);
    }

    private static async Task RefactorAsync(
        this Workspace workspace)
    {
        var refactoringFuncs = new List<Func<Document, Solution, Task<Solution>>>();
        refactoringFuncs.Add((document, solution) => document.StartUnusedMethodParameterRenamerAsync(solution));
        refactoringFuncs.Add((document, solution) => document.StartAsyncMethodRenamerAsync(solution));
        ////refactoringFuncs.Add((document, solution) => document.StartFieldRenamerAsync(solution));
        refactoringFuncs.Add((document, solution) => document.StartMethodRenamerAsync(solution));

        foreach (var refactoringFunc in refactoringFuncs)
        {
            var changesCount = 0;
            var newSolution = workspace.CurrentSolution;
            var projectIds = workspace.CurrentSolution.ProjectIds;

            foreach (var projectId in projectIds)
            {
                var project = workspace.CurrentSolution.GetProject(projectId);
                var documentIds = project.DocumentIds;
                foreach (var documentId in documentIds)
                {
                    var originalDocument = project.GetDocument(documentId);
                    var originalRoot = await originalDocument.GetSyntaxRootAsync();
                    if (originalDocument.IsAutoGenerated() || originalRoot.BeginsWithAutoGeneratedComment())
                    {
                        continue;
                    }

                    newSolution = await refactoringFunc(originalDocument, newSolution);
                }
            }

            ApplyChanges(workspace, newSolution, changesCount);
        }
    }

    private static void ApplyChanges(
        this Workspace workspace,
        Solution newSolution,
        int changesCount)
    {
        string sender;
        if (string.IsNullOrWhiteSpace(newSolution.FilePath))
        {
            sender = "InMemory solution";
        }
        else
        {
            sender = new FileInfo(newSolution.FilePath).Name;
        }

        if (!ReferenceEquals(newSolution, workspace.CurrentSolution) &&
            workspace.TryApplyChanges(newSolution))
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"{sender} => Changes applied in {changesCount} files");
        }
        else
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine($"{sender} => No changes applied");
        }

        Console.ResetColor();
    }

    #endregion
}
